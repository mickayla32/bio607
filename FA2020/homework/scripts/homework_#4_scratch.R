
# Boot samp function
boot_samp <- function(vec){
  
  one_boot <- sample(vec,
                     size = length(vec),
                     replace = TRUE)
  
  return(one_boot)
  
}

# Boot means function: 10 bootstrapped replicate draws of a mean from the vector
boot_means_fun <- function(vec, r = 1000, fun = mean){
  
  boot_means <- replicate(r,
                          boot_samp(vec) %>%
                            mean())
  # returns r # of means
  return(boot_means)
  
}

# 3:

# Write a function that, given a vector of values, a request for some number of bootstraps, and a sample statistic function, 

new_fun <- function(vec, r = 1000, fun = mean){
 
  # returns the original value of the statistic as applied to the vector, 
  true_mean <- mean(vec)
  
  #return(true_mean)
  
  # the mean of the statistic generated by the bootstrapped reps, 
  boot_samps <- replicate(r,
                boot_samp(vec) %>%
                mean())
  
  boot_mean <- mean(boot_samps)
  
  #return(boot_mean)
  
  # the upper and lower 95% CI of the bootstrapped statistic (e.g., the 0.025 and 0.975 quantile)
  
  upper_quant <- quantile(boot_samps, probs = 0.975)
  lower_quant <- quantile(boot_samps, probs = 0.025)
  
  #return(c(lower_quant, upper_quant))
  
  
  # and the bias (i.e., the original value of the statistic - the mean of the bootstrapped statistic).
  
  bias <- (true_mean - boot_mean)
  
  #return(bias)
  
  # Return everything in a df
  out <- data.frame(true_mean = true_mean,
                    boot_mean = boot_mean,
                    lower_quant = lower_quant,
                    upper_quant = upper_quant,
                    bias = bias)
  
  return(out)
}


##### Old, complicated way of maybe(?) doing it: #####
#### Wrapper function ####

stat_fun <- function(vec){
  
  # boot_samp function to get 1 bootstrap sample from a vector (vec)
  
  boot_samps <- boot_samp(vec)
  
  # boot_means_fun to get r number of bootstrap draws' means
  
  boot_means <- boot_means_fun(vec, r = 1000, fun = mean)
  
  # mean of the boot_means
  boot_means_mean <- mean_of_means(boot_means_fun)
  
  # ci_fun to calculate the upper and lower 95% CI of the bootstrapped statistic
  
  ci_of_means <- ci_fun(boot_means_mean, upper = 0.975, lower = 0.025)
  
  # get the mean of the actual vector
  
  true_mean <- mean(vec)
  
  # bias_fun to calculate (the original value of the statistic) - (the mean of the bootstrapped statistic)
  
  bias <- bias_fun(x = true_mean_fun(vec),y = mean_of_means(boot_means_fun(vec, r = 10)))
  
  
  # put this all into a df
  out <- data.frame(ci = ci_of_means, true_mean = true_mean, boot_mean = boot_means_mean, bias = bias)
  
  return(out)
}


#### Test Wrapper ####
stat_fun(vec)


# boot_samp function: 1. Write a function that takes a vector and returns one bootstrapped sample from said vector

# Write the function:
boot_samp <- function(vec){
  
  one_boot <- sample(vec,
                     size = length(vec),
                     replace = TRUE)
  
  return(one_boot)
  
}


# Caluclate the mean of r number of bootstrap samples
boot_means_fun <- function(vec, r = 1000, fun = mean){
  
  boot_means <- replicate(r,
                          boot_samp(vec) %>%
                            mean())
  # returns r # of means
  return(boot_means)
  
}

# function for mean of boot_means

mean_of_means <- function(boot_means_fun){ 
  
  boot_means_mean <- mean(boot_means_fun(vec, r = 10, fun))
  
  return(boot_means_mean)
  
}

# function for CIs 
ci_fun <- function(mean_of_means, upper = 0.975, lower = 0.025) {
  
  # upper quantile
  upper_quant <-quantile(mean_of_means(boot_means_fun(vec, r = 10, fun)), probs = upper)
  
  # lower quantile
  lower_quant <- quantile(mean_of_means(boot_means_fun(vec, r = 10, fun)), probs = lower)
  
  # Return them
  return(c(upper_quant,lower_quant))
}

# Test it
ci_fun(mean_of_means = mean_of_means)

# True mean function

true_mean_fun <- function(vec){
  
  true_mean <- mean(vec)
  
  return(true_mean)
  
}

# bias_fun Function
bias_fun <- function(x = true_mean_fun(vec), y = mean_of_means(boot_means_fun(vec, r = 10))){
  
  # (the original value of the statistic) - (the mean of the bootstrapped statistic)
  bias_calc <- (x - y)
  
  return(bias_calc)
}

############# 4c:

pres_test <- pres_new %>%
  dplyr::mutate(unique_id = paste(question_id, poll_id, state, sep = "_"))

# Then select the ID, state, answer, and pct. Also filter out NA diffs
pres_test <- pres_test %>%
  select(unique_id, state, answer, pct)

# Pivot new df wider
pres_test_wide <- pres_test %>%
  pivot_wider(names_from = unique_id,
              values_from = pct)

# try pivoting a diff way:
pres_test_wide2 <- pres_test %>%
  pivot_wider(names_from = answer,
              values_from = pct)

# Get average by statewide polls & by nationwide polls
pres_test_wide2<- pres_test_wide2 %>%
  group_by(unique_id) %>%
  mutate(diff = abs(Biden - Trump))
# This gives us the difference between each candidate by unique id

# pres_test_wide2 <- pres_test_wide2 %>%
#   # group by state polls
#   group_by(str_detect(state, "\\w")) %>%
#   # get average difference of state polls
#   mutate(avg_diff = mean(diff, na.rm = TRUE))

# average diff for each state
pres_test_wide3 <- pres_test_wide2 %>%
  # group by state polls
  group_by(state) %>%
  # get average difference of state polls
  mutate(avg_diff = mean(diff, na.rm = TRUE))

# Show this average difference:
final_answer <- pres_test_wide3 %>%
  select(state, avg_diff)

unique(final_answer)

#############
